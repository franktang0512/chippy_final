/*'use strict';
goog.provide('Blockly.JavaScript.test');
goog.require('Blockly.JavaScript');
*/
//test
Blockly.JavaScript['test'] = function(block) {
  // TODO: Assemble JavaScript into code variable.
  var code = '\'Hello\'';
  // TODO: Change ORDER_NONE to the correct strength.
  return [code, Blockly.JavaScript.ORDER_NONE];
};

//Text
Blockly.JavaScript['text_s'] = function(block) {
  // Text value.
  var code = Blockly.JavaScript.quote_(block.getFieldValue('TEXT'));
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

Blockly.JavaScript['print'] = function(block) {
  // Print statement.
  var msg = Blockly.JavaScript.valueToCode(block, 'TEXT',
      Blockly.JavaScript.ORDER_NONE) || '\'\'';
  var code = 'output_result_string += ' + msg + '\n' + 'output_result_string += \'\\n\' \n'
  return code;
};

Blockly.JavaScript['length'] = function(block) {
  // String or array length.
  var text = Blockly.JavaScript.valueToCode(block, 'VALUE',
      Blockly.JavaScript.ORDER_MEMBER) || '\'\'';
  return [text + '.length', Blockly.JavaScript.ORDER_MEMBER];
};

Blockly.JavaScript['join'] = function(block) {
  var code = Blockly.JavaScript.quote_(Blockly.JavaScript.valueToCode(block, 'TEXT0',
      Blockly.JavaScript.ORDER_NONE) + Blockly.JavaScript.valueToCode(block, 'TEXT1',
      Blockly.JavaScript.ORDER_NONE));
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

//Logic
Blockly.JavaScript['if'] = function(block) {
  var n = 0;
  var code = '', branchCode, conditionCode;
  if (Blockly.JavaScript.STATEMENT_PREFIX) {
    // Automatic prefix insertion is switched off for this block.  Add manually.
    code += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,
        block);
  }
  do {
    conditionCode = Blockly.JavaScript.valueToCode(block, 'IF' + n,
        Blockly.JavaScript.ORDER_NONE) || 'false';
    branchCode = Blockly.JavaScript.statementToCode(block, 'DO' + n);
    if (Blockly.JavaScript.STATEMENT_SUFFIX) {
      branchCode = Blockly.JavaScript.prefixLines(
          Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,
          block), Blockly.JavaScript.INDENT) + branchCode;
    }
    code += (n > 0 ? ' else ' : '') +
        'if (' + conditionCode + ') {\n' + branchCode + '}';
    ++n;
  } while (block.getInput('IF' + n));

  if (block.getInput('ELSE') || Blockly.JavaScript.STATEMENT_SUFFIX) {
    branchCode = Blockly.JavaScript.statementToCode(block, 'ELSE');
    if (Blockly.JavaScript.STATEMENT_SUFFIX) {
      branchCode = Blockly.JavaScript.prefixLines(
          Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,
          block), Blockly.JavaScript.INDENT) + branchCode;
    }
    code += ' else {\n' + branchCode + '}';
  }
  return code + '\n';
};

Blockly.JavaScript['ifelse'] = Blockly.JavaScript['if'];

Blockly.JavaScript['boolean'] = function(block) {
  var code = Boolean(block.getFieldValue('BOOL'));
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

Blockly.JavaScript['boolean_true'] = function(block) {
  // Boolean values true and false.
  var code = (block.getFieldValue('BOOL') == 'TRUE') ? 'true' : 'false';
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

Blockly.JavaScript['compare'] = function(block) {
  // Comparison operator.
  var OPERATORS = {
    'EQ': '==',
    'NEQ': '!=',
    'LT': '<',
    'LTE': '<=',
    'GT': '>',
    'GTE': '>='
  };
  var operator = OPERATORS[block.getFieldValue('OP')];
  var order = (operator == '==' || operator == '!=') ?
      Blockly.JavaScript.ORDER_EQUALITY : Blockly.JavaScript.ORDER_RELATIONAL;
  var argument0 = Blockly.JavaScript.valueToCode(block, 'A', order) || '0';
  var argument1 = Blockly.JavaScript.valueToCode(block, 'B', order) || '0';
  var code = argument0 + ' ' + operator + ' ' + argument1;
  return [code, order];
};

Blockly.JavaScript['operation'] = function(block) {
  // Operations 'and', 'or'.
  var operator = (block.getFieldValue('OP') == 'AND') ? '&&' : '||';
  var order = (operator == '&&') ? Blockly.JavaScript.ORDER_LOGICAL_AND :
      Blockly.JavaScript.ORDER_LOGICAL_OR;
  var argument0 = Blockly.JavaScript.valueToCode(block, 'A', order);
  var argument1 = Blockly.JavaScript.valueToCode(block, 'B', order);
  if (!argument0 && !argument1) {
    // If there are no arguments, then the return value is false.
    argument0 = 'false';
    argument1 = 'false';
  } else {
    // Single missing arguments have no effect on the return value.
    var defaultArgument = (operator == '&&') ? 'true' : 'false';
    if (!argument0) {
      argument0 = defaultArgument;
    }
    if (!argument1) {
      argument1 = defaultArgument;
    }
  }
  var code = argument0 + ' ' + operator + ' ' + argument1;
  return [code, order];
};

Blockly.JavaScript['negate'] = function(block) {
  // Negation.
  var order = Blockly.JavaScript.ORDER_LOGICAL_NOT;
  var argument0 = Blockly.JavaScript.valueToCode(block, 'BOOL', order) ||
      'true';
  var code = '!' + argument0;
  return [code, order];
};

//Loops
Blockly.JavaScript['repeat_ext'] = function(block) {
  // Repeat n times.
  if (block.getField('TIMES')) {
    // Internal number.
    var repeats = String(Number(block.getFieldValue('TIMES')));
  } else {
    // External number.
    var repeats = Blockly.JavaScript.valueToCode(block, 'TIMES',
        Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  }
  var branch = Blockly.JavaScript.statementToCode(block, 'DO');
  branch = Blockly.JavaScript.addLoopTrap(branch, block);
  var code = '';
  var loopVar = Blockly.JavaScript.variableDB_.getDistinctName(
      'count', Blockly.VARIABLE_CATEGORY_NAME);
  var endVar = repeats;
  if (!repeats.match(/^\w+$/) && !Blockly.isNumber(repeats)) {
    endVar = Blockly.JavaScript.variableDB_.getDistinctName(
        'repeat_end', Blockly.VARIABLE_CATEGORY_NAME);
    code += 'var ' + endVar + ' = ' + repeats + ';\n';
  }
  code += 'for (var ' + loopVar + ' = 0; ' +
      loopVar + ' < ' + endVar + '; ' +
      loopVar + '++) {\n' +
      branch + '}\n';
  return code;
};

Blockly.JavaScript['whileUntil'] = function(block) {
  // Do while/until loop.
  var until = block.getFieldValue('MODE') == 'UNTIL';
  var argument0 = Blockly.JavaScript.valueToCode(block, 'BOOL',
      until ? Blockly.JavaScript.ORDER_LOGICAL_NOT :
      Blockly.JavaScript.ORDER_NONE) || 'false';
  var branch = Blockly.JavaScript.statementToCode(block, 'DO');
  branch = Blockly.JavaScript.addLoopTrap(branch, block);
  if (until) {
    argument0 = '!' + argument0;
  }
  return 'while (' + argument0 + ') {\n' + branch + '}\n';
};

Blockly.JavaScript['flow_statements'] = function(block) {
  // Flow statements: continue, break.
  var xfix = '';
  if (Blockly.JavaScript.STATEMENT_PREFIX) {
    // Automatic prefix insertion is switched off for this block.  Add manually.
    xfix += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,
        block);
  }
  if (Blockly.JavaScript.STATEMENT_SUFFIX) {
    // Inject any statement suffix here since the regular one at the end
    // will not get executed if the break/continue is triggered.
    xfix += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_SUFFIX,
        block);
  }
  if (Blockly.JavaScript.STATEMENT_PREFIX) {
    var loop = Blockly.Constants.Loops
        .CONTROL_FLOW_IN_LOOP_CHECK_MIXIN.getSurroundLoop(block);
    if (loop && !loop.suppressPrefixSuffix) {
      // Inject loop's statement prefix here since the regular one at the end
      // of the loop will not get executed if 'continue' is triggered.
      // In the case of 'break', a prefix is needed due to the loop's suffix.
      xfix += Blockly.JavaScript.injectId(Blockly.JavaScript.STATEMENT_PREFIX,
          loop);
    }
  }
  switch (block.getFieldValue('FLOW')) {
    case 'BREAK':
      return xfix + 'break;\n';
    case 'CONTINUE':
      return xfix + 'continue;\n';
  }
  throw Error('Unknown flow statement.');
};

//Math
Blockly.JavaScript['number'] = function(block) {
  // Numeric value.
  var code = Number(block.getFieldValue('NUM'));
  var order = code >= 0 ? Blockly.JavaScript.ORDER_ATOMIC :
              Blockly.JavaScript.ORDER_UNARY_NEGATION;
  return [code, order];
};

Blockly.JavaScript['arithmetic'] = function(block) {
  // Basic arithmetic operators, and power.
  var OPERATORS = {
    'ADD': [' + ', Blockly.JavaScript.ORDER_ADDITION],
    'MINUS': [' - ', Blockly.JavaScript.ORDER_SUBTRACTION],
    'MULTIPLY': [' * ', Blockly.JavaScript.ORDER_MULTIPLICATION],
    'DIVIDE': [' / ', Blockly.JavaScript.ORDER_DIVISION],
    'POWER': [null, Blockly.JavaScript.ORDER_NONE]  // Handle power separately.
  };
  var tuple = OPERATORS[block.getFieldValue('OP')];
  var operator = tuple[0];
  var order = tuple[1];
  var argument0 = Blockly.JavaScript.valueToCode(block, 'A', order) || '0';
  var argument1 = Blockly.JavaScript.valueToCode(block, 'B', order) || '0';
  var code;
  // Power in JavaScript requires a special case since it has no operator.
  if (!operator) {
    code = 'Math.pow(' + argument0 + ', ' + argument1 + ')';
    return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  }
  code = argument0 + operator + argument1;
  return [code, order];
};

Blockly.JavaScript['single_trig'] = function(block) {
  // Math operators with single operand.
  var operator = block.getFieldValue('OP');
  var code;
  var arg;
  if (operator == 'NEG') {
    // Negation is a special case given its different operator precedence.
    arg = Blockly.JavaScript.valueToCode(block, 'NUM',
        Blockly.JavaScript.ORDER_UNARY_NEGATION) || '0';
    if (arg[0] == '-') {
      // --3 is not legal in JS.
      arg = ' ' + arg;
    }
    code = '-' + arg;
    return [code, Blockly.JavaScript.ORDER_UNARY_NEGATION];
  }
  if (operator == 'SIN' || operator == 'COS' || operator == 'TAN') {
    arg = Blockly.JavaScript.valueToCode(block, 'NUM',
        Blockly.JavaScript.ORDER_DIVISION) || '0';
  } else {
    arg = Blockly.JavaScript.valueToCode(block, 'NUM',
        Blockly.JavaScript.ORDER_NONE) || '0';
  }
  // First, handle cases which generate values that don't need parentheses
  // wrapping the code.
  switch (operator) {
    case 'ABS':
      code = 'Math.abs(' + arg + ')';
      break;
    case 'ROOT':
      code = 'Math.sqrt(' + arg + ')';
      break;
    case 'LN':
      code = 'Math.log(' + arg + ')';
      break;
    case 'EXP':
      code = 'Math.exp(' + arg + ')';
      break;
    case 'POW10':
      code = 'Math.pow(10,' + arg + ')';
      break;
    case 'ROUND':
      code = 'Math.round(' + arg + ')';
      break;
    case 'ROUNDUP':
      code = 'Math.ceil(' + arg + ')';
      break;
    case 'ROUNDDOWN':
      code = 'Math.floor(' + arg + ')';
      break;
    case 'SIN':
      code = 'Math.sin(' + arg + ' / 180 * Math.PI)';
      break;
    case 'COS':
      code = 'Math.cos(' + arg + ' / 180 * Math.PI)';
      break;
    case 'TAN':
      code = 'Math.tan(' + arg + ' / 180 * Math.PI)';
      break;
  }
  if (code) {
    return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL];
  }
  // Second, handle cases which generate values that may need parentheses
  // wrapping the code.
  switch (operator) {
    case 'LOG10':
      code = 'Math.log(' + arg + ') / Math.log(10)';
      break;
    case 'ASIN':
      code = 'Math.asin(' + arg + ') / Math.PI * 180';
      break;
    case 'ACOS':
      code = 'Math.acos(' + arg + ') / Math.PI * 180';
      break;
    case 'ATAN':
      code = 'Math.atan(' + arg + ') / Math.PI * 180';
      break;
    default:
      throw Error('Unknown math operator: ' + operator);
  }
  return [code, Blockly.JavaScript.ORDER_DIVISION];
};

Blockly.JavaScript['round'] = Blockly.JavaScript['single_trig'];

Blockly.JavaScript['modulo'] = function(block) {
  // Remainder computation.
  var argument0 = Blockly.JavaScript.valueToCode(block, 'DIVIDEND',
      Blockly.JavaScript.ORDER_MODULUS) || '0';
  var argument1 = Blockly.JavaScript.valueToCode(block, 'DIVISOR',
      Blockly.JavaScript.ORDER_MODULUS) || '0';
  var code = argument0 + ' % ' + argument1;
  return [code, Blockly.JavaScript.ORDER_MODULUS];
};

Blockly.JavaScript['random_int'] = function(block) {
  // Random integer between [X] and [Y].
  var argument0 = Blockly.JavaScript.valueToCode(block, 'FROM',
      Blockly.JavaScript.ORDER_NONE) || '0';
  var argument1 = Blockly.JavaScript.valueToCode(block, 'TO',
      Blockly.JavaScript.ORDER_NONE) || '0';
  var functionName = Blockly.JavaScript.provideFunction_(
      'mathRandomInt',
      ['function ' + Blockly.JavaScript.FUNCTION_NAME_PLACEHOLDER_ +
          '(a, b) {',
       '  if (a > b) {',
       '    // Swap a and b to ensure a is smaller.',
       '    var c = a;',
       '    a = b;',
       '    b = c;',
       '  }',
       '  return Math.floor(Math.random() * (b - a + 1) + a);',
       '}']);
  var code = functionName + '(' + argument0 + ', ' + argument1 + ')';
  return [code, Blockly.JavaScript.ORDER_FUNCTION_CALL];
};

//Variables
Blockly.JavaScript['get'] = function(block) {
  // Variable getter.
  var code = Blockly.JavaScript.variableDB_.getName(
    block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

Blockly.JavaScript['set'] = function(block) {
  // Variable setter.
  var argument0 = Blockly.JavaScript.valueToCode(block, 'VALUE',
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  var varName = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
  return varName + ' = ' + argument0 + ';\n';
};

Blockly.JavaScript['change'] = function(block) {
  // Add to a variable in place.
  var argument0 = Blockly.JavaScript.valueToCode(block, 'DELTA',
      Blockly.JavaScript.ORDER_ADDITION) || '0';
  var varName = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('VAR'), Blockly.VARIABLE_CATEGORY_NAME);
  return varName + ' = (typeof ' + varName + ' == \'number\' ? ' + varName +
      ' : 0) + ' + argument0 + ';\n';
};

//Lists

Blockly.JavaScript['get_list'] = function(block) {
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  return [list_name , Blockly.JavaScript.ORDER_ATOMIC];
};

Blockly.JavaScript['length_list'] = function(block) {
  // array length.
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  var code = list_name + ".length";
  return [code, Blockly.JavaScript.ORDER_MEMBER];
};


Blockly.JavaScript['getIndex_list'] = function(block) {
  var index = Blockly.JavaScript.valueToCode(block, 'AT',
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  var code = list_name + '[' + index + ']'
  return [code, Blockly.JavaScript.ORDER_MEMBER];
};

Blockly.JavaScript['remove_list'] = function(block) {
  var index = Blockly.JavaScript.valueToCode(block, 'AT',
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  var code = list_name + '.splice(' + index + ', 1);\n'
  return [code, Blockly.JavaScript.ORDER_MEMBER]
};

Blockly.JavaScript['setIndex_list'] = function(block) {
  var index = Blockly.JavaScript.valueToCode(block, 'AT',
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  var value = Blockly.JavaScript.valueToCode(block, 'VALUE',
      Blockly.JavaScript.ORDER_ASSIGNMENT);
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  var code = list_name + '[' + index + '] = ' + value +'\n';
  return code;
};

Blockly.JavaScript['insert_list'] = function(block) {
  var index = Blockly.JavaScript.valueToCode(block, 'AT',
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  var value = Blockly.JavaScript.valueToCode(block, 'VALUE',
      Blockly.JavaScript.ORDER_ASSIGNMENT);
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  var code = list_name +'.splice( '+ index + ', 0, '+ value + ');\n';
  return code;
};

Blockly.JavaScript['add_list'] = function(block) {
  var value = Blockly.JavaScript.valueToCode(block, 'VALUE',
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
  var list_name = Blockly.JavaScript.variableDB_.getName(
      block.getFieldValue('LIST'), Blockly.VARIABLE_CATEGORY_NAME);
  var code = list_name + '.push(' + value + ');\n'
  return code;
}

//新增
Blockly.JavaScript['ask'] = function(block) {
  var value_question = Blockly.JavaScript.valueToCode(block, 'question', Blockly.JavaScript.ORDER_ATOMIC);
  // TODO: Assemble JavaScript into code variable.
  var input = prompt(value_question);
  var code = 'var system_input = '+ input + ';\n';
  console.log(code)
  return code;
};

Blockly.JavaScript['answer'] = function(block) {
  // TODO: Assemble JavaScript into code variable.
  var code = 'system_input';
  // TODO: Change ORDER_NONE to the correct strength.
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

//Function
Blockly.JavaScript['function_create'] = function(block) {
  var text_name = block.getFieldValue('NAME');
  //var statements_do = Blockly.JavaScript.statementToCode(block, 'DO');
  // TODO: Assemble JavaScript into code variable.
  var variable_code = '';
  var code = text_name + '(';
  if(block.inputList_.length!=0){
    let i=0;
    for(i=0; i<block.inputList_.length-1; i++){
      var value = Blockly.JavaScript.valueToCode(block, block.inputList_[i][0],
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
      code += value + ', ';
      
    }
    var value = Blockly.JavaScript.valueToCode(block, block.inputList_[i][0],
      Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
    code += value + ')'
  }
  else{
    code +=  ')'
  }
  console.log("variable_code:\n" + variable_code)
  console.log("call:\n" + code)
  return variable_code + code;
};

Blockly.JavaScript['function_call'] = function(block) {
  var text_name = block.getFieldValue('NAME');
  //var statements_do = Blockly.JavaScript.statementToCode(block, 'DO');
  // TODO: Assemble JavaScript into code variable.
  var code = text_name + '(';
  if(block.inputList_.length!=0){
    let i=0;
    if(block.inputList_[i][1] != 'String'){
      var value = Blockly.JavaScript.valueToCode(block, block.inputList_[i][0],
        Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
      code += value
    } 
    for(i=1; i<block.inputList_.length; i++){
      if(block.inputList_[i][1] != 'String'){
        var value = Blockly.JavaScript.valueToCode(block, block.inputList_[i][0],
          Blockly.JavaScript.ORDER_ASSIGNMENT) || '0';
        code += ', '+ value ;
      }
    }
  }
  code +=  ')'
  console.log("call:\n" + code)
  return code;
};

Blockly.JavaScript['function_define'] = function(block) {
  var text_name = block.getFieldValue('NAME');
  var statements_do = Blockly.JavaScript.statementToCode(block, 'DO');
  // TODO: Assemble JavaScript into code variable.
  var code = 'function ' + text_name + '(' 
  if(block.inputList_.length!=0){
    let i=0;
    if(block.inputList_[i][1]!='String'){
      var variable_name = Blockly.JavaScript.variableDB_.getName(
        block.getFieldValue(block.inputList_[i][0]), Blockly.VARIABLE_CATEGORY_NAME);
      code += variable_name
    }
    for(i=1; i<block.inputList_.length; i++){
      if(block.inputList_[i][1]!='String'){
        var variable_name = Blockly.JavaScript.variableDB_.getName(
          block.getFieldValue(block.inputList_[i][0]), Blockly.VARIABLE_CATEGORY_NAME);
        code += ', '+variable_name  ;
      }
    }
  }
  code += ') {\n' + statements_do + ' }\n'
  
  console.log("define:\n" + code)
  return code;
};

Blockly.JavaScript['function_variable'] = function(block) {
  // Variable getter.
  var code = Blockly.JavaScript.variableDB_.getName(
    block.getFieldValue('FUNCTION'), Blockly.VARIABLE_CATEGORY_NAME);
  return [code, Blockly.JavaScript.ORDER_ATOMIC];
};

Blockly.JavaScript['blockly_print'] = function(block) {
  // Print statement.
  var msg = Blockly.JavaScript.valueToCode(block, 'TEXT',
      Blockly.JavaScript.ORDER_NONE) || '\'\'';
  var code = 'output_result_string += ' + msg + '\n' + 'output_result_string += \'\\n\' \n'
  return code;
};

